"""
FLASH Data Reader and Processor

Author: Xu Zhao
Affiliation: York Plasma Institute, School of Physics, Engineering and Technology,
             University of York, York YO10 5DD, United Kingdom
Email: xu.zhao@york.ac.uk
Last Updated: 2023-11-30

Description:
This script is designed to process simulation data generated by the FLASH code. The module provides functionalities for loading
datasets, generating uniform covering grids, and extracting domain information for further analysis or visualization.

Features:
- Load datasets stored in HDF5 format (e.g., "radslab_hdf5_plt_cnt_????") from a specified directory structure.
- Generate uniform covering grids with consistent refinement levels using yt, ensuring compatibility across datasets.
- Extract and convert domain boundaries and grid resolutions to micrometers for user-friendly analysis.

Dependencies:
- yt: For analyzing and visualizing volumetric data.  https://yt-project.org/

Usage:
1. Set the `file_dir`, `file_sub_dir`, and `filename_pattern` to match your dataset structure.
2. Execute the script to process FLASH datasets, extract relevant domain information, and generate uniform grids.
3. Use the returned processed data for further simulation analysis or visualization.

Note:
This script assumes the datasets follow the HDF5 standard used by FLASH simulations and that yt is properly installed
and configured for your environment.
"""


import yt #
import logging  # Add this import Suppress yt logging output
import os
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import pandas as pd
from tqdm import tqdm  # Import tqdm for the progress bar
from collections import namedtuple
from concurrent.futures import ThreadPoolExecutor
import dask.array as da
from dask import delayed


yt.funcs.mylog.setLevel(logging.ERROR)


def load_and_process_data(file_dir, file_sub_dir, filename_pattern, lrefine_max=3):
    """
    Load and process a series of datasets from files, generating uniform covering grids
    and extracting domain information for further analysis.

    Parameters:
    -----------
    file_dir : str
        The base directory where the dataset files are located.
    file_sub_dir : str
        Subdirectory within the base directory containing the dataset files.
    filename_pattern : str
        The filename pattern or wildcard expression to match dataset files (e.g., "radslab_hdf5_plt_cnt_????").
    lrefine_max : int, optional
        The maximum refinement level minus 1, used when creating uniform covering grids.
        For instance, if `lrefine_max=4`, the function uses refinement level 3.
        Default is 3.

    Returns:
    --------
    ProcessedData : namedtuple
        A named tuple containing the following fields:
        - ds_ug : list of numpy arrays
            List of deep-copied uniform covering grids created from the datasets.
        - dx : float
            Grid resolution in the x-direction in micrometers (μm).
        - dy : float
            Grid resolution in the y-direction in micrometers (μm).
        - xmax : float
            Maximum x-coordinate of the domain in micrometers (μm).
        - xmin : float
            Minimum x-coordinate of the domain in micrometers (μm).
        - ymax : float
            Maximum y-coordinate of the domain in micrometers (μm).
        - ymin : float
            Minimum y-coordinate of the domain in micrometers (μm).

    Notes:
    ------
    - The function uses yt to load the dataset series, assumes a valid pattern
      for the dataset filenames, and processes each dataset to create uniform
      covering grids with a specified refinement level.
    - The function calculates the grid resolution (dx, dy) and converts domain
      boundaries from code units to micrometers (μm).
    - The tqdm library is used to provide progress feedback during dataset processing.

    Example Usage:
    --------------
    data = load_and_process_data(
        file_dir="/path/to/data",
        file_sub_dir="simulations",
        filename_pattern="e.g., "radslab_hdf5_plt_cnt_????"",
        lrefine_max=3
    )
    """
    global ts
    # Generate full file path
    file_path = os.path.join(file_dir, file_sub_dir, filename_pattern)

    # Load the dataset series
    ts = yt.load(file_path)
    ts = list(ts)

    # Precompute shared parameters
    left_edge = ts[0].domain_left_edge
    dims = ts[0].domain_dimensions * 2 ** lrefine_max

    def process_dataset(ds):
        ds.force_periodicity()  # Forces the dataset to assume periodic boundary conditions, overriding non-periodic boundaries to avoid computation errors.
        return ds.smoothed_covering_grid(lrefine_max, left_edge=left_edge, dims=dims)

    # Initialize tqdm progress bar
    with ThreadPoolExecutor() as executor:
        with tqdm(total=len(ts), desc="Processing datasets", unit="dataset") as pbar:
            # Wrap the processing function to include progress bar updates
            results = []
            for result in executor.map(process_dataset, ts):
                results.append(result)
                pbar.update(1)  # Update the progress bar for each dataset
            ds_ug = results

    # print("Processing complete!")

    # Get domain boundaries and convert to micrometers (um)
    xmax = np.array(ts[0].domain_right_edge.in_units('code_length')[0]) * 1e4
    xmin = np.array(ts[0].domain_left_edge.in_units('code_length')[0]) * 1e4
    ymax = np.array(ts[0].domain_right_edge.in_units('code_length')[1]) * 1e4
    ymin = np.array(ts[0].domain_left_edge.in_units('code_length')[1]) * 1e4

    # Calculate grid resolutions in x and y directions
    dx = (xmax - xmin) / ds_ug[0].shape[0]
    dy = (ymax - ymin) / ds_ug[0].shape[1]

    # Print the field list
    print("Field List", ts[0].field_list)
    print(f"xRes: {dx:.4f} μm, yRes: {dy:.4f} μm")

    ProcessedData = namedtuple('ProcessedData', ['ds_ug', 'dx', 'dy', 'xmax', 'xmin', 'ymax', 'ymin'])
    # Return ProcessedData named tuple
    return ProcessedData(ds_ug=ds_ug, dx=dx, dy=dy, xmax=xmax, xmin=xmin, ymax=ymax, ymin=ymin)


def read_ug(ug, field, unit):
    # This function just reads and processes one time step.
    # It returns a single 2D array (y_dim, x_dim) after slicing and transposing.
    arr = ug[field].to(unit).v.astype(np.float32)[:, :, 0]
    arr = arr.T  # transpose to get (y_dim, x_dim)
    return arr

def extract_field_array(data, field="dens", unit="code_density", chunks=(1, 1024, 1024)):
    """
    Extracts data for a specified field across all time steps as a dask array.
    This approach is faster and more stable for large datasets.

    Parameters:
    -----------
    data : object
        The processed data object containing a list of uniform covering grids (ds_ug).
    field : str, optional
        The field to extract (default is "dens").
    unit : str, optional
        The unit to convert the field data into (default is "code_density").
    chunks : tuple, optional
        Desired chunks for the resulting dask array, default (1, 1024, 1024).

    Returns:
    --------
    data_array : dask.array.Array
        A dask array representing the stacked field data across all time steps, shape:
        (time_steps, y_dim, x_dim).
    """
    # First, load one sample to determine spatial dimensions:
    sample_ug = data.ds_ug[0]
    sample_arr = read_ug(sample_ug, field, unit)
    y_dim, x_dim = sample_arr.shape
    time_steps = len(data.ds_ug)

    # Wrap each time step loading in a delayed function to avoid immediate computation:
    delayed_arrays = [
        da.from_delayed(
            delayed(read_ug)(ug, field, unit),
            shape=(y_dim, x_dim),
            dtype=np.float32
        )
        for ug in tqdm(data.ds_ug, desc="Preparing delayed loads", unit="step")
    ]

    # Stack all delayed arrays along a new time dimension:
    data_array = da.stack(delayed_arrays, axis=0)

    # Rechunk the data if desired:
    data_array = data_array.rechunk(chunks)

    print("Data shape (dask):", data_array.shape)
    return data_array


def plot_2D_map(data, plotvar, time_step, vmin=None, vmax=None, cmap="OrRd", log_scale=False, title="Density",
                figsize=(4, 4), contour=False, levels=None):
    """
    Plot the density map from a 3D array and automatically generate a title based on the time step.

    Parameters:
    - plotvar: The 3D array containing the data to plot.
    - time_step: The time step index to select the density data for plotting.
    - vmin, vmax: Minimum and maximum values for color normalization.
    - cmap: Colormap to use for displaying the data.
    - log_scale: Whether to use LogNorm for logarithmic scaling of the colormap.
    - title: Title for the plot.
    - figsize: Tuple specifying the size of the figure in inches (width, height).
    - contour: Whether to overlay contour lines on top of the image plot.
    - levels: The number of contour levels or specific levels to plot (used if contour=True).
    """
    # Determine the normalization based on whether log scale is requested
    if log_scale:
        norm = LogNorm(vmin=vmin, vmax=vmax)
    else:
        norm = None

    # Create the figure and axis with the provided figsize and high dpi
    fig, ax = plt.subplots(figsize=(figsize[0] / 2.54, figsize[1] / 2.54), dpi=300)

    # Plot the density map using the selected time step
    cs = ax.imshow(plotvar[time_step, :, :], origin='lower',
                   extent=[data.xmin, data.xmax, data.ymin, data.ymax],
                   aspect='auto',
                   cmap=cmap,
                   norm=norm)

    # Ensure the aspect ratio of the image remains equal
    ax.set_aspect('equal')

    # Plot contour if requested
    if contour:
        # Generate contours with the specified number of levels (or default to 10 if None)
        if levels is None:
            levels = 10
        ax.contour(plotvar[time_step, :, :], levels=levels, colors='w', linewidths=0.5,
                   extent=[data.xmin, data.xmax, data.ymin, data.ymax])

    # Configure the major and minor ticks for the plot
    ax.tick_params(axis='both', direction='in', labelsize=6, length=4, width=0.3, which='major', top=True, right=True)
    ax.tick_params(axis='both', direction='in', length=2, width=0.3, which='minor', top=True, right=True)

    # Enable minor ticks
    ax.minorticks_on()

    # Set axis labels
    ax.set_xlabel(r'X ($\mathrm{\mu}$m)', fontsize=7, labelpad=1.2)
    ax.set_ylabel(r'Y ($\mathrm{\mu}$m)', fontsize=7, labelpad=1.2)

    # Set axis limits
    # ax.set_xlim(-400, 400)
    # ax.set_ylim(0, 800)

    # Set the linewidth for the axes
    for spine in ax.spines.values():
        spine.set_linewidth(0.3)

    # Add the colorbar without distorting the image
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.1)

    # Add the colorbar to the plot
    cbar = plt.colorbar(cs, cax=cax, orientation="vertical")

    # Configure the major and minor ticks on the colorbar
    cbar.ax.tick_params(axis='both', which='major', labelsize=5, direction='out', length=2, width=0.25)
    cbar.ax.tick_params(axis='both', which='minor', labelsize=5, direction='out', length=1.5, width=0.2)

    # Set the linewidth for the colorbar outline
    cbar.outline.set_linewidth(0.3)

    # Generate the title automatically based on the time step (assuming each time step is 0.1 ns)
    # time_ns = time_step / 10.0
    ax.set_title(f'{title} Map at time_step {time_step}', fontsize=6)

    return fig, ax

def plot_1D_line(data, field_array, time_step, line_index, axis="x", title="1D Line Plot", xlabel=None, ylabel=None, figsize=(6, 4)):
    """
    Plot a 1D line of the field_array at a specific time and along a specific line.

    Parameters:
    -----------
    data : object
        Processed data object containing grid information (xmax, xmin, ymax, ymin, dx, dy).
    field_array : numpy.ndarray
        3D array of field data with dimensions (time_steps, x_dim, y_dim).
    time_step : int
        Index of the time step to plot.
    line_index : int
        Index of the line to plot. For axis="x", it represents the y-index; for axis="y", it represents the x-index.
    axis : str, optional
        Axis along which to plot the line ("x" for horizontal, "y" for vertical). Default is "x".
    title : str, optional
        Title of the plot. Default is "1D Line Plot".
    xlabel : str, optional
        Label for the x-axis. Default is None, automatically set based on the axis.
    ylabel : str, optional
        Label for the y-axis. Default is None, automatically set to the field name.
    figsize : tuple, optional
        Size of the figure in inches. Default is (6, 4).

    Returns:
    --------
    fig, ax : matplotlib figure and axis
        Figure and axis of the generated plot.
    """
    # Select the 1D data based on the axis
    if axis == "x":
        x = np.linspace(data.xmin, data.xmax, field_array.shape[1])/1000.
        y = field_array[time_step, :, line_index]
        xlabel = xlabel or r"X (mm)"
        ylabel = ylabel or f"{field_array}"
    elif axis == "y":
        x = np.linspace(data.ymin, data.ymax, field_array.shape[2])/1000.
        y = field_array[time_step, line_index, :]
        xlabel = xlabel or r"Y (mm)"
        ylabel = ylabel or f"{field_array}"
    else:
        raise ValueError("Invalid axis. Must be 'x' or 'y'.")

    # Create the plot
    fig, ax = plt.subplots(figsize=(figsize[0] / 2.54, figsize[1] / 2.54), dpi=300)
    ax.plot(x, y, lw=0.8)

    # Set plot labels and title
    ax.set_title(title, fontsize=8)
    ax.set_xlabel(xlabel, fontsize=7)
    ax.set_ylabel(ylabel, fontsize=7)

    # Set ticks and spines
    ax.tick_params(axis='both', direction='in', labelsize=6, length=4, width=0.3, which='major', top=True, right=True)
    ax.tick_params(axis='both', direction='in', length=2, width=0.3, which='minor', top=True, right=True)
    ax.minorticks_on()

    for spine in ax.spines.values():
        spine.set_linewidth(0.3)

    return fig, ax

def plot_temporal_evolution(data, field_array, xpos, ypos, title="Temporal Evolution at Point", xlabel=None, ylabel=None, figsize=(6, 4)):
    """
    Plot the temporal evolution of a field value at a specific spatial point (x1, y1).

    Parameters:
    -----------
    data : object
        Processed data object containing grid information (xmax, xmin, ymax, ymin, dx, dy).
    field_array : numpy.ndarray
        3D array of field data with dimensions (time_steps, x_dim, y_dim).
    x1, y1 : float
        Spatial coordinates (in micrometres) of the point to extract the temporal evolution.
    title : str, optional
        Title of the plot. Default is "Temporal Evolution at Point".
    xlabel : str, optional
        Label for the x-axis (time axis). Default is None, automatically set to "Time (ns)".
    ylabel : str, optional
        Label for the y-axis (field value). Default is None, automatically set to "Field Value".
    figsize : tuple, optional
        Size of the figure in inches. Default is (6, 4).

    Returns:
    --------
    fig, ax : matplotlib figure and axis
        Figure and axis of the generated plot.
    """
    # Calculate the indices of the point (x1, y1) in the grid
    x_index = int((xpos - data.xmin) / data.dx)
    y_index = int((ypos - data.ymin) / data.dy)

    # Extract the temporal evolution of the field value at the specified point
    temporal_data = field_array[:, x_index, y_index]

    # Create the plot
    fig, ax = plt.subplots(figsize=(figsize[0] / 2.54, figsize[1] / 2.54), dpi=300)
    time = np.arange(len(temporal_data))  # Assuming unit time steps
    ax.plot(time, temporal_data, lw=0.8)

    # Set plot labels and title
    ax.set_title(f"{title} ({xpos:.1f} μm, {ypos:.1f} μm)", fontsize=8)
    ax.set_xlabel(xlabel or "Time (arbitrary units)", fontsize=7)
    ax.set_ylabel(ylabel or "Field Value", fontsize=7)

    # Set ticks and spines
    ax.tick_params(axis='both', direction='in', labelsize=6, length=4, width=0.3, which='major', top=True, right=True)
    ax.tick_params(axis='both', direction='in', length=2, width=0.3, which='minor', top=True, right=True)
    ax.minorticks_on()

    for spine in ax.spines.values():
        spine.set_linewidth(0.3)

    return fig, ax




import matplotlib.animation as animation


def animate_2D_map(data, field_array, vmin=None, vmax=None, cmap="OrRd", log_scale=False, title="2D Map Animation", 
                   interval=100, repeat=True, save_as=None):
    """
    Create an animation of a 2D map showing the time evolution of the field.

    Parameters:
    -----------
    data : object
        Processed data object containing grid information (xmax, xmin, ymax, ymin).
    field_array : numpy.ndarray
        3D array of field data with dimensions (time_steps, x_dim, y_dim).
    vmin, vmax : float, optional
        Minimum and maximum values for color normalization. Default is None (automatic scaling).
    cmap : str, optional
        Colormap to use for displaying the data. Default is "OrRd".
    log_scale : bool, optional
        Whether to use logarithmic scaling for the colormap. Default is False.
    title : str, optional
        Title of the animation. Default is "2D Map Animation".
    interval : int, optional
        Interval between frames in milliseconds. Default is 100 ms.
    repeat : bool, optional
        Whether the animation should repeat after the last frame. Default is True.
    save_as : str, optional
        Path to save the animation as a file. If None, the animation is not saved. Default is None.

    Returns:
    --------
    anim : matplotlib.animation.FuncAnimation
        The animation object.
    """
    from matplotlib.colors import LogNorm

    # Determine the normalization based on whether log scale is requested
    if log_scale:
        norm = LogNorm(vmin=vmin, vmax=vmax)
    else:
        norm = None

    # Set up the figure and axis
    fig, ax = plt.subplots(figsize=(6, 4), dpi=300)
    extent = [data.xmin, data.xmax, data.ymin, data.ymax]
    img = ax.imshow(field_array[0, :, :], origin='lower', extent=extent, cmap=cmap, vmin=vmin, vmax=vmax, norm=norm)
    ax.set_aspect('equal')
    ax.set_xlabel(r"X ($\mathrm{\mu}$m)")
    ax.set_ylabel(r"Y ($\mathrm{\mu}$m)")
    cbar = plt.colorbar(img, ax=ax)
    cbar.set_label("Field Value")

    # Update function for each frame
    def update(frame):
        img.set_array(field_array[frame, :, :])
        ax.set_title(f"{title}\nTime Step: {frame}", fontsize=10)
        return img,

    # Create the animation
    anim = animation.FuncAnimation(fig, update, frames=field_array.shape[0],
                                    interval=interval, repeat=repeat)

    # Save the animation if a file path is provided
    if save_as:
        anim.save(save_as, writer='pillow' if save_as.endswith('.gif') else 'ffmpeg', fps=2)

    return anim



def save_all_frames_as_png(
    data,
    field_array,
    field_name,
    output_dir,
    vmin=None,
    vmax=None,
    cmap="OrRd",
    log_scale=False,
    title=None
):
    """
    Save all frames of a 3D field array as PNG images, one per frame.

    Parameters
    ----------
    data : object
        Processed data object containing grid information (xmax, xmin, ymax, ymin).
    field_array : numpy.ndarray
        3D array of field data with dimensions (time_steps, x_dim, y_dim).
    field_name : str
        Name of the field (used in the output filename).
    output_dir : str
        Directory where the PNG files will be saved.
    vmin, vmax : float, optional
        Minimum and maximum values for color normalization. If None, they are computed from the data.
    cmap : str, optional
        Colormap to use for displaying the data.
    log_scale : bool, optional
        Whether to use logarithmic scaling for the colormap.
    title : str, optional
        Title for the plot.
    """

    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Compute vmin and vmax from the entire data if not provided
    if vmin is None:
        vmin = float(np.nanmin(field_array))
    if vmax is None:
        vmax = float(np.nanmax(field_array))

    # Determine normalization
    norm = LogNorm(vmin=vmin, vmax=vmax) if log_scale else None

    # For efficiency, we will create one figure and reuse it to minimize overhead
    fig, ax = plt.subplots(figsize=(6, 4), dpi=300)
    extent = [data.xmin, data.xmax, data.ymin, data.ymax]

    # Initialize the image with the first frame's data
    img = ax.imshow(field_array[0],
                    origin='lower',
                    extent=extent,
                    cmap=cmap,
                    norm=norm)
    ax.set_aspect('equal')
    ax.set_xlabel(r"X ($\mathrm{\mu}$m)")
    ax.set_ylabel(r"Y ($\mathrm{\mu}$m)")

    cbar = plt.colorbar(img, ax=ax)
    cbar.set_label("Field Value")

    # Create a text object for the title and update it each frame
    title_obj = ax.set_title(f"{title or field_name}\nTime Step: 0", fontsize=10)

    # Loop over all frames and save them
    n_frames = field_array.shape[0]
    for frame in range(21):
        # Update the image data
        frame =frame+200
        img.set_data(field_array[frame])
        # Update the title to reflect the current frame
        ax.set_title(f"{title or field_name}\nTime Step: {frame}", fontsize=10)

        # Construct the output filename
        filename = f"{field_name}_frame{frame:04d}.png"
        filepath = os.path.join(output_dir, filename)

        # Save the figure
        plt.savefig(filepath, bbox_inches='tight')
        print(f"Saved frame {frame} as {filepath}")

    plt.close(fig)
