"""
FLASH Data Reader and Processor

Author: Xu Zhao
Affiliation: York Plasma Institute, School of Physics, Engineering and Technology,
             University of York, York YO10 5DD, United Kingdom
Email: xu.zhao@york.ac.uk
Last Updated: 2023-11-30

Description:
This script is designed to process simulation data generated by the FLASH code. The module provides functionalities for loading
datasets, generating uniform covering grids, and extracting domain information for further analysis or visualization.

Features:
- Load datasets stored in HDF5 format (e.g., "radslab_hdf5_plt_cnt_????") from a specified directory structure.
- Generate uniform covering grids with consistent refinement levels using yt, ensuring compatibility across datasets.
- Extract and convert domain boundaries and grid resolutions to micrometers for user-friendly analysis.

Dependencies:
- yt: For analyzing and visualizing volumetric data.  https://yt-project.org/

Usage:
1. Set the `file_dir`, `file_sub_dir`, and `filename_pattern` to match your dataset structure.
2. Execute the script to process FLASH datasets, extract relevant domain information, and generate uniform grids.
3. Use the returned processed data for further simulation analysis or visualization.

Note:
This script assumes the datasets follow the HDF5 standard used by FLASH simulations and that yt is properly installed
and configured for your environment.
"""


import yt #
import logging  # Add this import Suppress yt logging output
import os
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import pandas as pd
from tqdm import tqdm  # Import tqdm for the progress bar
from collections import namedtuple
from concurrent.futures import ThreadPoolExecutor



yt.funcs.mylog.setLevel(logging.ERROR)


def load_and_process_data(file_dir, file_sub_dir, filename_pattern, lrefine_max=3):
    """
    Load and process a series of datasets from files, generating uniform covering grids
    and extracting domain information for further analysis.

    Parameters:
    -----------
    file_dir : str
        The base directory where the dataset files are located.
    file_sub_dir : str
        Subdirectory within the base directory containing the dataset files.
    filename_pattern : str
        The filename pattern or wildcard expression to match dataset files (e.g., "radslab_hdf5_plt_cnt_????").
    lrefine_max : int, optional
        The maximum refinement level minus 1, used when creating uniform covering grids.
        For instance, if `lrefine_max=4`, the function uses refinement level 3.
        Default is 3.

    Returns:
    --------
    ProcessedData : namedtuple
        A named tuple containing the following fields:
        - ds_ug : list of numpy arrays
            List of deep-copied uniform covering grids created from the datasets.
        - dx : float
            Grid resolution in the x-direction in micrometers (μm).
        - dy : float
            Grid resolution in the y-direction in micrometers (μm).
        - xmax : float
            Maximum x-coordinate of the domain in micrometers (μm).
        - xmin : float
            Minimum x-coordinate of the domain in micrometers (μm).
        - ymax : float
            Maximum y-coordinate of the domain in micrometers (μm).
        - ymin : float
            Minimum y-coordinate of the domain in micrometers (μm).

    Notes:
    ------
    - The function uses yt to load the dataset series, assumes a valid pattern
      for the dataset filenames, and processes each dataset to create uniform
      covering grids with a specified refinement level.
    - The function calculates the grid resolution (dx, dy) and converts domain
      boundaries from code units to micrometers (μm).
    - The tqdm library is used to provide progress feedback during dataset processing.

    Example Usage:
    --------------
    data = load_and_process_data(
        file_dir="/path/to/data",
        file_sub_dir="simulations",
        filename_pattern="e.g., "radslab_hdf5_plt_cnt_????"",
        lrefine_max=3
    )
    """
    global ts
    # Generate full file path
    file_path = os.path.join(file_dir, file_sub_dir, filename_pattern)

    # Load the dataset series
    ts = yt.load(file_path)
    ts = list(ts)

    # Precompute shared parameters
    left_edge = ts[0].domain_left_edge
    dims = ts[0].domain_dimensions * 2 ** lrefine_max

    def process_dataset(ds):
        ds.force_periodicity()  # Forces the dataset to assume periodic boundary conditions, overriding non-periodic boundaries to avoid computation errors.
        return ds.smoothed_covering_grid(lrefine_max, left_edge=left_edge, dims=dims)

    # Initialize tqdm progress bar
    with ThreadPoolExecutor() as executor:
        with tqdm(total=len(ts), desc="Processing datasets", unit="dataset") as pbar:
            # Wrap the processing function to include progress bar updates
            results = []
            for result in executor.map(process_dataset, ts):
                results.append(result)
                pbar.update(1)  # Update the progress bar for each dataset
            ds_ug = results

    # print("Processing complete!")

    # Get domain boundaries and convert to micrometers (um)
    xmax = np.array(ts[0].domain_right_edge.in_units('code_length')[0]) * 1e4
    xmin = np.array(ts[0].domain_left_edge.in_units('code_length')[0]) * 1e4
    ymax = np.array(ts[0].domain_right_edge.in_units('code_length')[1]) * 1e4
    ymin = np.array(ts[0].domain_left_edge.in_units('code_length')[1]) * 1e4

    # Calculate grid resolutions in x and y directions
    dx = (xmax - xmin) / ds_ug[0].shape[0]
    dy = (ymax - ymin) / ds_ug[0].shape[1]

    # Print the field list
    print("Field List", ts[0].field_list)
    print(f"xRes: {dx:.4f} μm, yRes: {dy:.4f} μm")

    ProcessedData = namedtuple('ProcessedData', ['ds_ug', 'dx', 'dy', 'xmax', 'xmin', 'ymax', 'ymin'])
    # Return ProcessedData named tuple
    return ProcessedData(ds_ug=ds_ug, dx=dx, dy=dy, xmax=xmax, xmin=xmin, ymax=ymax, ymin=ymin)


def extract_field_array(data, field="dens", unit="code_density"):
    """
    Extracts data for a specified field across all time steps and returns it as a NumPy array.

    Parameters:
    -----------
    data : object
        The processed data object containing a list of uniform covering grids (ds_ug).
    field : str, optional
        The field to extract (default is "dens").
    unit : str, optional
        The unit to convert the field data into (default is "code_density").

    Returns:
    --------
    dens_array : numpy.ndarray
        A 3D NumPy array with the extracted data across all time steps. The array has shape
        (time_steps, x_dim, y_dim), where time_steps is the number of time steps in data.ds_ug.
    """
    # Extract the field data across all time steps with a progress bar
    data_array = np.array([
        np.transpose(np.array(ug[(field)].to(unit))[:, :, 0])
        for ug in tqdm(data.ds_ug, desc="Processing time steps", unit="step")
    ])

    # Print the shape of the resulting array
    print("Shape of dens_array:", data_array.shape)
    return data_array


def plot_2D_map(data, plotvar, time_step, vmin=None, vmax=None, cmap="OrRd", log_scale=False, title="Density",
                figsize=(4, 4), contour=False, levels=None):
    """
    Plot the density map from a 3D array and automatically generate a title based on the time step.

    Parameters:
    - plotvar: The 3D array containing the data to plot.
    - time_step: The time step index to select the density data for plotting.
    - vmin, vmax: Minimum and maximum values for color normalization.
    - cmap: Colormap to use for displaying the data.
    - log_scale: Whether to use LogNorm for logarithmic scaling of the colormap.
    - title: Title for the plot.
    - figsize: Tuple specifying the size of the figure in inches (width, height).
    - contour: Whether to overlay contour lines on top of the image plot.
    - levels: The number of contour levels or specific levels to plot (used if contour=True).
    """
    # Determine the normalization based on whether log scale is requested
    if log_scale:
        norm = LogNorm(vmin=vmin, vmax=vmax)
    else:
        norm = None

    # Create the figure and axis with the provided figsize and high dpi
    fig, ax = plt.subplots(figsize=(figsize[0] / 2.54, figsize[1] / 2.54), dpi=300)

    # Plot the density map using the selected time step
    cs = ax.imshow(plotvar[time_step, :, :], origin='lower',
                   extent=[data.xmin, data.xmax, data.ymin, data.ymax],
                   aspect='auto',
                   cmap=cmap,
                   norm=norm)

    # Ensure the aspect ratio of the image remains equal
    ax.set_aspect('equal')

    # Plot contour if requested
    if contour:
        # Generate contours with the specified number of levels (or default to 10 if None)
        if levels is None:
            levels = 10
        ax.contour(plotvar[time_step, :, :], levels=levels, colors='w', linewidths=0.5,
                   extent=[data.xmin, data.xmax, data.ymin, data.ymax])

    # Configure the major and minor ticks for the plot
    ax.tick_params(axis='both', direction='in', labelsize=6, length=4, width=0.3, which='major', top=True, right=True)
    ax.tick_params(axis='both', direction='in', length=2, width=0.3, which='minor', top=True, right=True)

    # Enable minor ticks
    ax.minorticks_on()

    # Set axis labels
    ax.set_xlabel(r'X ($\mathrm{\mu}$m)', fontsize=7, labelpad=1.2)
    ax.set_ylabel(r'Y ($\mathrm{\mu}$m)', fontsize=7, labelpad=1.2)

    # Set axis limits
    # ax.set_xlim(-400, 400)
    # ax.set_ylim(0, 800)

    # Set the linewidth for the axes
    for spine in ax.spines.values():
        spine.set_linewidth(0.3)

    # Add the colorbar without distorting the image
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.1)

    # Add the colorbar to the plot
    cbar = plt.colorbar(cs, cax=cax, orientation="vertical")

    # Configure the major and minor ticks on the colorbar
    cbar.ax.tick_params(axis='both', which='major', labelsize=5, direction='out', length=2, width=0.25)
    cbar.ax.tick_params(axis='both', which='minor', labelsize=5, direction='out', length=1.5, width=0.2)

    # Set the linewidth for the colorbar outline
    cbar.outline.set_linewidth(0.3)

    # Generate the title automatically based on the time step (assuming each time step is 0.1 ns)
    # time_ns = time_step / 10.0
    ax.set_title(f'{title} Map at time_step {time_step}', fontsize=6)

    return fig, ax